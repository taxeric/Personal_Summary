所谓流式布局，就是类似淘宝/京东等APP搜索历史的样子，有了前面的学习，这个应该比较好实现，直接上代码
```java
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        //由于是重写ViewGroup来自定义View，所以注释掉之前测量的值
        //super.onMeasure(widthMeasureSpec, heightMeasureSpec);

        //获取自身建议的宽度
        int myWidth = MeasureSpec.getSize(widthMeasureSpec);
        //上一个子View的宽度
        int lastViewWidth = 0;

        //测量完所有的子View后自身应该有多高
        int measureHeight = 0;

        //子View的数量
        int childCount = getChildCount();
        for (int i = 0; i < childCount; i ++){

            //获取到子View
            View childView = getChildAt(i);

            //测量并保存子View的尺寸
            measureChild(childView, widthMeasureSpec, heightMeasureSpec);

            //获取当前子View测量得到的宽度
            int childWidth = childView.getMeasuredWidth();

            //如果当前子View宽度 + 上一个子View宽度 > 自身的宽度
            if (childWidth + lastViewWidth > myWidth){
                //此时就要换行了
                measureHeight += childView.getMeasuredHeight();
                //并且换行后lastViewWidth的值就是第一个子View的宽度
                lastViewWidth = childView.getMeasuredWidth();
                i("换行 " + i + "    " + measureHeight);
            }else {
                //否则就只加上当前子View宽度就好
                lastViewWidth += childWidth;
            }
            //对最后一个子View处理，如果没做处理，则measureHeight的值只是
            //换行之前的值，而换行之后的高度没有加上，这就导致少显示一行
            //判断是否执行到最后一个子View，能始终保证加上最后一行的高度
            if (i == childCount - 1){
                measureHeight += childView.getMeasuredHeight();
            }
        }

        //最后保存自身应该有的宽度和高度
        setMeasuredDimension(widthMeasureSpec, measureHeight);
    }
    
    
    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        //子View的左边，也可以说是子View左上点的X轴坐标，也就是从左边哪里开始布局
        int layoutLeft = l;
        //子View的顶边，也可以说是子View左上点的Y轴坐标，也就是从顶边哪里开始布局
        int layoutHeight = 0;
        //获取ViewGroup测得的宽度
        int parentWidth = getMeasuredWidth();
        //获取子View的数量
        int childCount = getChildCount();
        for (int i = 0; i < childCount; i ++){

            //获取到子View
            View childView = getChildAt(i);

            //获取到子View测量得到的宽高
            int childWidth = childView.getMeasuredWidth();
            int childHeight = childView.getMeasuredHeight();

            //这里依旧判断，是否超出ViewGroup的宽度
            if (childWidth + layoutLeft > parentWidth){
                //如果超出就增加当前子View的高度
                layoutHeight += childHeight;
                //然后把下一行开始的子View左边位置设置为0
                //确保每次都能从x轴坐标为0开始布局
                layoutLeft = 0;
            }

            //布局（子View的左边，子View的顶边，子View的右边 = 左边 + 当前子View的宽度，子View的底边 = 测得的高度 + 当前子View的高度）
            childView.layout(layoutLeft, layoutHeight, layoutLeft + childWidth, layoutHeight + childHeight);
            //每次布局后，需要把子View的左边加上当前子View的宽度，作为下一个子View左边的起始位置
            layoutLeft += childWidth;
        }
    }
```
写的很清楚明白了，直接在xml中用即可
```xml
    <com.eric.study.FlowLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <TextView
            android:text="200"
            android:gravity="center"
            android:layout_width="200dp"
            android:layout_height="wrap_content"/>
        <TextView
            android:text="20"
            android:gravity="center"
            android:layout_width="20dp"
            android:layout_height="wrap_content"/>
        <TextView
            android:text="60"
            android:gravity="center"
            android:layout_width="60dp"
            android:layout_height="wrap_content"/>
        <TextView
            android:text="100"
            android:gravity="center"
            android:layout_width="100dp"
            android:layout_height="wrap_content"/>
        <TextView
            android:text="120"
            android:gravity="center"
            android:layout_width="120dp"
            android:layout_height="wrap_content"/>
        <TextView
            android:text="200"
            android:gravity="center"
            android:layout_width="200dp"
            android:layout_height="wrap_content"/>
        <TextView
            android:text="60"
            android:gravity="center"
            android:layout_width="60dp"
            android:layout_height="wrap_content"/>
        <TextView
            android:text="60"
            android:gravity="center"
            android:layout_width="60dp"
            android:layout_height="wrap_content"/>
        <TextView
            android:text="60"
            android:gravity="center"
            android:layout_width="60dp"
            android:layout_height="wrap_content"/>
        <TextView
            android:text="60"
            android:gravity="center"
            android:layout_width="60dp"
            android:layout_height="wrap_content"/>
    </com.eric.study.FlowLayout>
```
## 修改1
修改xml布局，把自定义ViewGroup的高度改为`match_parent`时发现还是包裹子控件，这是因为在onMeasure方法中，没有对自定义ViewGroup的测量模式判断，最后保存的高度总是恰好包裹所有子控件的高度。对于这个问题，直接判断一下高度的测量模式就行
```java
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        //由于是重写ViewGroup来自定义View，所以注释掉之前测量的值
        //super.onMeasure(widthMeasureSpec, heightMeasureSpec);

        //获取自身建议的宽度
        int myWidth = MeasureSpec.getSize(widthMeasureSpec);

        //测量完所有的子View后自身应该有多高
        int measureHeight = 0;
        if (myHeightMode == MeasureSpec.AT_MOST){
            //上一个子View的宽度
            int lastViewWidth = 0;

            //子View的数量
            int childCount = getChildCount();
            for (int i = 0; i < childCount; i ++){

                //获取到子View
                View childView = getChildAt(i);

                //测量并保存子View的尺寸
                measureChild(childView, widthMeasureSpec, heightMeasureSpec);

                //获取当前子View测量得到的宽度
                int childWidth = childView.getMeasuredWidth();

                //如果当前子View宽度 + 上一个子View宽度 > 自身的宽度
                if (childWidth + lastViewWidth > myWidth){
                    //此时就要换行了
                    measureHeight += childView.getMeasuredHeight();
                    //并且换行后第一个子View的宽度就是当前子View的宽度
                    lastViewWidth = childView.getMeasuredWidth();
                }else {
                    //否则就只加上当前子View宽度就好
                    lastViewWidth += childWidth;
                }
                
                if (i == childCount - 1){
                    measureHeight += childView.getMeasuredHeight();
                }
            }
        }else if (myHeightMode == MeasureSpec.EXACTLY){
            measureChildren(widthMeasureSpec, heightMeasureSpec);
            measureHeight = MeasureSpec.getSize(heightMeasureSpec);
        }

        //最后保存自身应该有的宽度和高度
        setMeasuredDimension(widthMeasureSpec, measureHeight);
    }
```
## 修改2
当给子View加上margin属性时发现修改无效。这是因为在自定义ViewGroup中没有对子控件的Margin属性做处理。既然是布局里的参数，就会想到之前说过的**LayoutParams**，但里面没有关于margin的描述，所以咱看看它的子类，找到个叫**MarginLayoutParams**的东西，非常相似，百度一波，结果与预期一致。使用如下：
```java
MarginLayoutParams params = (MarginLayoutParams) childView.getLayoutParams();
int leftMargin = params.leftMargin;
...
```
OK就这样，修改代码
```java
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        //由于是重写ViewGroup来自定义View，所以注释掉之前测量的值
        //super.onMeasure(widthMeasureSpec, heightMeasureSpec);

        //获取自身建议的宽度、自身高度测量模式
        int myWidth = MeasureSpec.getSize(widthMeasureSpec);
        int myHeightMode = MeasureSpec.getMode(heightMeasureSpec);

        //测量完所有的子View后自身应该有多高
        int measureHeight = 0;
        //判断高度测量模式，如果是wrap_content
        if (myHeightMode == MeasureSpec.AT_MOST){
            //上一个子View的宽度
            int lastViewWidth = 0;

            //子View的数量
            int childCount = getChildCount();
            for (int i = 0; i < childCount; i ++){

                //获取到子View
                View childView = getChildAt(i);

                //获取到左右上下的margin
                MarginLayoutParams params = (MarginLayoutParams) childView.getLayoutParams();
                int leftMargin = params.leftMargin;
                int rightMargin = params.rightMargin;
                int topMargin = params.topMargin;
                int bottomMargin = params.bottomMargin;

                //测量并保存子View的尺寸
                measureChild(childView, widthMeasureSpec, heightMeasureSpec);

                //获取当前子View测量得到的宽度，需要加上左右的Margin值
                int childWidth = childView.getMeasuredWidth() + leftMargin + rightMargin;

                //如果当前子View宽度 + 上一个子View宽度 > 自身的宽度
                if (childWidth + lastViewWidth > myWidth){
                    //此时就要换行了，并且该值也需要加上当前子View的上下Margin值
                    measureHeight += childView.getMeasuredHeight() + topMargin + bottomMargin;
                    //并且换行后第一个子View的宽度就是当前子View的宽度 + 当前子View的左右Margin值
                    lastViewWidth = childView.getMeasuredWidth() + leftMargin + rightMargin;
                }else {
                    //否则上一个子View的宽度就只加上当前子View宽度就好
                    lastViewWidth += childWidth;
                }
                //确保测量完所有子View后加上最后一行的高度，外带最后一个子View的左右Margin
                //其实这里写的有点问题，得看每一行谁的高度最大，取最大值比较
                //这里为了方便，就假设所有的子View都用的相同高度和相同Margin值
                if (i == childCount - 1){
                    measureHeight += childView.getMeasuredHeight() + topMargin + bottomMargin;
                }
            }
        }else if (myHeightMode == MeasureSpec.EXACTLY){
            //如果是match_parent或者确定值，就直接测量，最终高度就是建议的高度
            measureChildren(widthMeasureSpec, heightMeasureSpec);
            measureHeight = MeasureSpec.getSize(heightMeasureSpec);
        }

        //最后保存自身应该有的宽度和高度
        setMeasuredDimension(widthMeasureSpec, measureHeight);
    }
    
    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        //子View的左边，也可以说是子View左上点的X轴坐标，也就是从左边哪里开始布局
        int layoutLeft = l;
        //子View的顶边，也可以说是子View左上点的Y轴坐标，也就是从顶边哪里开始布局
        int layoutHeight = 0;
        //获取ViewGroup测得的宽度
        int parentWidth = getMeasuredWidth();
        //摆放子View
        int childCount = getChildCount();
        for (int i = 0; i < childCount; i ++){

            //获取到子View
            View childView = getChildAt(i);

            //获取到子View测量得到的宽高
            int childWidth = childView.getMeasuredWidth();
            int childHeight = childView.getMeasuredHeight();

            //获取到左右上下的margin
            MarginLayoutParams params = (MarginLayoutParams) childView.getLayoutParams();
            int leftMargin = params.leftMargin;
            int rightMargin = params.rightMargin;
            int topMargin = params.topMargin;
            int bottomMargin = params.bottomMargin;

            //这里依旧判断，是否超出ViewGroup的宽度，但是要加上子View的左右Margin值
            if (childWidth + layoutLeft + leftMargin + rightMargin > parentWidth){
                //如果超出就增加当前子View的高度，外带子View的上下Margin值
                layoutHeight += childHeight + topMargin + bottomMargin;
                //然后把下一行开始的子View左边位置设置为0
                //这是为了确保每次换行后都能从顶点x轴坐标为0开始布局
                layoutLeft = 0;
            }

            //布局（子View的左边，子View的顶边，子View的右边 = 左边 + 当前子View的宽度，子View的底边 = 测得的高度 + 当前子View的高度）
            childView.layout(layoutLeft + leftMargin,
                    layoutHeight + topMargin,
                    //这里不需要添加子View右边Margin值，因为下面已经加上了
                    layoutLeft + childWidth + leftMargin,
                    //同样，这里也不需要添加子View底边的Margin值了
                    layoutHeight + childHeight + topMargin);
                    
            //每次布局后，需要把子View的左边加上当前子View的宽度，作为下一个子View左边的起始位置
            layoutLeft += childWidth + leftMargin + rightMargin;
        }
    }
```
emmm，运行一波

闪退了 -_-||

看看报错：`ViewGroup$LayoutParams cannot be cast to android.view.ViewGroup$MarginLayoutParams`

不能强转？！来吧，百度一波

OK，这篇就到这里
